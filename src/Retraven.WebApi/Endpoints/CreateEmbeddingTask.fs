module Endpoints.CreateEmbeddingTask
open Giraffe
open Microsoft.AspNetCore.Http
open Minio
open Retraven.Shell.Messaging
open Microsoft.Extensions.Configuration
open System
open System.IO
open Minio.DataModel.Args
open Retraven.Core.Helpers
open System.Threading.Tasks
open System.Linq
open Minio.DataModel.Response
open Retraven.Core
open Retraven.Core.Helpers
open System.Collections.Generic
open RabbitMQ.Client
open Retraven.Core.DomainEvents

[<CLIMutable>]
type Out =
    {
    Status: string
    Message: string
    TaskId: string
    }
    

[<CLIMutable>]
type In = 
    {
    BucketName: string
    DocumentId: string option // generate guid if not specified
    CorrelationKey: string option
    VectorDbType: string 
    EmbeddingsType: string
    ChunkSize: int
    ChunkOverlap: int option
    ChunkStrategy: string option
    Tags: Map<string, string> option
    }

    member this.HasErrors() =
        if this.BucketName.Length > 64 then Some "BucketName is too long."
        elif this.BucketName.Length < 3 then Some "BucketName is too short."
        elif this.DocumentId.IsSome && this.DocumentId.Value.Length > 36 then Some "Too Long DocumentId."
        elif this.CorrelationKey.IsSome && this.CorrelationKey.Value.Length > 36 then Some "Too Long DocumentId."
        elif  this.VectorDbType <> "qdrant" then Some "Invalid/Not Implemented Db Provider."
        else None

    interface IModelValidation<In> with
        member this.Validate() =
            match this.HasErrors() with
            | Some msg -> Error (RequestErrors.badRequest (text msg))
            | None     -> Ok this

let documentEmbeddingHandler (doc : In) : HttpHandler =
    match doc.HasErrors() with
    | Some msg -> RequestErrors.BAD_REQUEST msg
    | None     -> text (doc.ToString())


let getEmbedingTaskEntry (req:In) (res:PutObjectResponse): EmbeddingTask =
    {
     // This should be generated by the database
     Id = 0; 
     StorageProvider = normalize "MinIO";
     StorageBucketName = normalize req.BucketName;
     StorageObjectKey = res.ObjectName;
     VectorDbProvider = normalize "qdrant";
     EmbeddingsProvider = None;
     DocumentId = req.DocumentId;
     CorrelationKey = req.CorrelationKey;
     ChunkSize = None;
     ChunkOverlap = None;
     ChunkStrategy = None;
     DataBag = getJsonStr (Some res);
     Status = normalize "NotGenerated"
     CreatedAt = DateTime.UtcNow;
     UpdatedAt = None}

let getEventMsg (req:EmbeddingTask): DomainEvent =
    EmbeddingTaskCreated{
        TaskId = req.Id
        CreatedAt = DateTime.UtcNow
    }
    
let publishDomainEvent (msg : DomainEvents.DomainEvent) : HttpHandler =
    fun (next : HttpFunc) (ctx : HttpContext) ->
    task {
        let conn = ctx.GetService<IConnection>()
        let! result = sendDomainEventToQueue conn msg "EmbeddingTasks"
        match result, msg with
        | Ok evt, EmbeddingTaskCreated(m)  ->
            return! json  {
                    Status = "Success";
                    Message = "Embedding task generated and queued successfully.";
                    TaskId = m.TaskId.ToString()
                }  next ctx
        | Error err, _ ->
            let errorResponse = { Status = "Error"; Message = "Failed To finish embedding Task initialization, please try again."; TaskId = String.Empty }
            return! json errorResponse next ctx
    }

let persistsEmbedingTask req (res : PutObjectResponse) : HttpHandler =
    fun (next : HttpFunc) (ctx : HttpContext) ->
    task {

        let entry = getEmbedingTaskEntry req res
        let! newEntry = DbContext.embeddingTaskPersister entry
        match newEntry with
        | Ok e ->
            return! publishDomainEvent (getEventMsg e) next ctx
        | Error msg ->
            let errorResponse = { Status = "Error"; Message = "Failed to persist embedding task."; TaskId = String.Empty }
            return! json errorResponse next ctx
    }

let earlyReturn : HttpFunc = Some >> Task.FromResult

let handler =
    fun (req:In) (nxt : HttpFunc) (ctx : HttpContext) ->
        task {
                let config = ctx.GetService<IConfiguration>()
                let bucketName = normalize req.BucketName
                match ctx.Request.HasFormContentType with
                | false -> return! text "Bad Request" nxt ctx
                | true  ->
                    // let bucketName = config.GetValue<string>(defaultBucket)
                    // Generate a random file name to avoid conflicts

                    // Consider the first file only for simplicity
                    let file = ctx.Request.Form.Files.FirstOrDefault()

                    // Generate random file name but keep the extension
                    let extension = Path.GetExtension(file.FileName)
                    // remove extention from random file name
                    let randomFileName = Path.GetRandomFileName()
                    let documentName = 
                        $"""{randomFileName.Replace(Path.GetExtension(randomFileName), "")}-{DateTimeOffset.UtcNow.ToUnixTimeSeconds()}{extension}"""

                    // if ctx.Request.Form.Files.Count = 0 then
                    //     return! text "No files uploaded." next ctx
                    // if isNull file then
                    //     return! text "No file uploaded." next ctx
                    let fileSize = file.Length
                    let contentType = file.ContentType

                    // Define tags to be associated with an object if required.
                    let tagging = DataModel.Tags.Tagging()
                    if req.DocumentId.IsSome then
                        let tags= new Dictionary<string,string>() 
                        tags.Add("DocumentId", req.DocumentId.Value)
                        tagging.TaggingSet <-  DataModel.Tags.TagSet(tags)
                    let putObjectArgs = 
                        PutObjectArgs()
                            .WithBucket(bucketName)
                            .WithObject(documentName)
                            .WithStreamData(file.OpenReadStream())
                            .WithObjectSize(file.Length)
                            .WithContentType(contentType)
                            .WithTagging(tagging)
                    
                    // Create minIo client
                    let minIoClient = ctx.GetService<IMinioClient>()

                    // Make a bucket on the server, if not already present.
                    let bucketExistsArgs = BucketExistsArgs().WithBucket(bucketName) 
                    Console.WriteLine(bucketExistsArgs.ToString)
                    let! found =  minIoClient.BucketExistsAsync(bucketExistsArgs)
                    if (not found) then
                        let mbArgs = new MakeBucketArgs()
                        mbArgs.WithBucket(bucketName) |> ignore
                        do! minIoClient.MakeBucketAsync(mbArgs).ConfigureAwait(false)
                    let! res = minIoClient.PutObjectAsync(putObjectArgs)   
                    return! persistsEmbedingTask req res nxt ctx 
        }